# 전체 시스템 코드 상호작용 및 동작 원리
## APB UART 프로젝트 - 코드 레벨 완전 분석

---

## 목차
1. [전체 시스템 구조](#1-전체-시스템-구조)
2. [UART 송신 경로 (PC → FPGA)](#2-uart-수신-경로-pc--fpga)
3. [UART 수신 경로 (FPGA → PC)](#3-uart-송신-경로-fpga--pc)
4. [APB 버스 트랜잭션 상세](#4-apb-버스-트랜잭션-상세)
5. [실제 시나리오 완전 추적](#5-실제-시나리오-완전-추적)

---

## 1. 전체 시스템 구조

### 1.1 계층 구조
```
┌─────────────────────────────────────────────────────────┐
│ Layer 4: 응용 프로그램 (C 코드)                          │
│  - code2_reconstructed.c                                 │
│  - uart_send(), uart_receive(), main()                  │
└──────────────────┬──────────────────────────────────────┘
                   │ Memory-Mapped I/O
┌──────────────────▼──────────────────────────────────────┐
│ Layer 3: CPU & 버스 (RISC-V + APB Master)               │
│  - CPU_RV32I.sv, DataPath.sv, ControlUnit.sv           │
│  - APB_Master.sv (Decoder, Mux)                         │
└──────────────────┬──────────────────────────────────────┘
                   │ APB Protocol (PSEL, PENABLE, PADDR...)
┌──────────────────▼──────────────────────────────────────┐
│ Layer 2: 주변장치 (APB Slaves)                          │
│  - UART_Periph.sv (APB_SlaveIntf_UART)                 │
│  - FND_Periph.sv, GPIO.sv...                            │
└──────────────────┬──────────────────────────────────────┘
                   │ UART Protocol (tx, rx)
┌──────────────────▼──────────────────────────────────────┐
│ Layer 1: 물리 계층                                       │
│  - uart_tx, uart_rx 모듈                                │
│  - baud_tick_gen                                        │
└──────────────────┬──────────────────────────────────────┘
                   │ RS-232 신호
                   ▼
                  PC
```

---

## 2. UART 수신 경로 (PC → FPGA)
### PC에서 'H' (0x48) 전송하는 전체 과정

---

### 단계 1: C 코드에서 UART 수신 시작

#### code2_reconstructed.c:104-115 (uart_receive 함수)
```c
uint8_t uart_receive(void) {
    uint32_t status;

    // ① RX FIFO에 데이터가 있을 때까지 대기
    do {
        status = UART_USR;  // 0x10004000 주소 읽기
    } while ((status & UART_RX_READY) == 0);

    // ② RDR에서 데이터 읽기
    uint8_t data = (uint8_t)UART_RDR;  // 0x1000400C 주소 읽기
    return data;
}
```

**메모리 맵 확장**:
```c
#define UART_USR (*(volatile uint32_t*)(0x10004000 + 0x00))
#define UART_RDR (*(volatile uint32_t*)(0x10004000 + 0x0C))
```

**동작**:
- `status = UART_USR` → 컴파일러가 RISC-V LW (Load Word) 명령 생성
- CPU가 주소 0x10004000을 버스에 요청

---

### 단계 2: RISC-V CPU가 메모리 읽기 명령 실행

#### DataPath.sv:200-230 (메모리 접근 부분)
```systemverilog
// Load/Store 명령 실행
assign busAddr = aluResult;  // ALU가 계산한 주소 (0x10004000)
assign busWe = memWrite;     // 읽기이므로 0
assign busWData = rs2Data;
assign transfer = memRead | memWrite;  // 버스 트랜잭션 시작 신호
```

**RISC-V 명령어 예시** (컴파일된 기계어):
```assembly
LW   x10, 0(x11)    # x11 = 0x10004000 (UART_USR 주소)
                     # x10으로 데이터 로드
```

**CPU가 생성하는 신호**:
- `busAddr = 0x10004000`
- `busWe = 0` (읽기)
- `transfer = 1` (트랜잭션 시작)

---

### 단계 3: APB Master가 CPU 요청을 APB 프로토콜로 변환

#### APB_Master.sv:76-116 (상태 머신)
```systemverilog
always_comb begin
    case (state)
        IDLE: begin
            if (transfer) begin
                state_next = SETUP;
                temp_addr_next = addr;  // 0x10004000 저장
                temp_write_next = write; // 0 (읽기)
            end
        end

        SETUP: begin
            decoder_en = 1'b1;
            PENABLE = 1'b0;
            PADDR = temp_addr_reg;  // ③ 주소 출력: 0x10004000
            PWRITE = temp_write_reg; // 0
            state_next = ACCESS;
        end

        ACCESS: begin
            decoder_en = 1'b1;
            PENABLE = 1'b1;  // ④ Enable 신호
            if (ready) begin
                state_next = IDLE;
            end
        end
    endcase
end
```

**APB 신호 타이밍**:
```
Clock:  __|‾‾|__|‾‾|__|‾‾|__|‾‾|__
State:    IDLE | SETUP  | ACCESS |
PSEL:     0    | 1      | 1      |
PENABLE:  0    | 0      | 1      |
PADDR:    X    | 0x10004000 | 0x10004000 |
PREADY:   X    | X      | 1      |
PRDATA:   X    | X      | 0x01   | ← USR 값
```

---

### 단계 4: APB Decoder가 UART 선택

#### APB_Master.sv:154-163 (Decoder)
```systemverilog
always_comb begin
    y = 6'b000000;
    if (en) begin
        casex (sel)
            32'h1000_0xxx: y = 6'b000001;  // RAM
            32'h1000_1xxx: y = 6'b000010;  // GPO
            32'h1000_2xxx: y = 6'b000100;  // GPI
            32'h1000_3xxx: y = 6'b001000;  // GPIO
            32'h1000_4xxx: y = 6'b010000;  // ⑤ UART 선택!
            32'h1000_5xxx: y = 6'b100000;  // FND
        endcase
    end
end
```

**주소 디코딩**:
- 입력: `sel = 0x10004000`
- 출력: `y = 6'b010000` → `PSEL_UART = 1`

---

### 단계 5: UART_Periph의 APB Slave 인터페이스가 응답

#### UART_Periph.sv:470-523 (APB_SlaveIntf_UART)
```systemverilog
always_comb begin
    PREADY_next = 1'b0;

    if (PSEL && PENABLE) begin  // ⑥ APB ACCESS 단계
        if (PWRITE) begin
            // 쓰기...
        end else begin
            // ⑦ 읽기 사이클
            state_next = READ;
            unique case (PADDR[3:2])
                2'd0: begin
                    // USR (0x00): 상태 레지스터
                    PRDATA_next = slv_reg0;  // ⑧ {... , RX_READY}
                    re_next = 1'b0;
                end
                2'd3: begin
                    // RDR (0x0C): 수신 데이터
                    PRDATA_next = {24'b0, URD};  // ⑨ FIFO 데이터
                    re_next = 1'b1;  // ⑩ FIFO Pop!
                end
            endcase
            PREADY_next = 1'b1;  // ⑪ 트랜잭션 완료
        end
    end
end
```

**주소 오프셋 계산**:
- `PADDR = 0x10004000` → `PADDR[3:2] = 2'd0` → USR 선택
- `PADDR = 0x1000400C` → `PADDR[3:2] = 2'd3` → RDR 선택

---

### 단계 6: 실제 데이터는 어디서 오는가?

#### UART_Periph.sv:44-53 (RX FIFO)
```systemverilog
fifo U_FIFO_RX (
    .clk(PCLK),
    .reset(PRESET),
    .we(rx_done),        // ⑫ uart_rx가 수신 완료 시 1
    .re(re_RX),          // ⑬ APB Read 시 1 (위의 re_next)
    .wdata(wdata_RX),    // ⑭ uart_rx가 받은 데이터
    .rdata(rdata_RX),    // ⑮ APB로 출력할 데이터 (URD)
    .empty(empty_RX),
    .full(full_RX)
);
```

**FIFO 내부 동작** (fifo_CU.sv:360-368):
```systemverilog
READ: begin
    if (!empty_reg) begin
        rptr_next = rptr_reg + 1;  // ⑯ 읽기 포인터 증가
        full_next = 1'b0;
        if (wptr_next == rptr_next)
            empty_next = 1'b1;  // ⑰ 비어있으면 플래그 설정
    end
end
```

---

### 단계 7: uart_rx 모듈이 PC에서 데이터를 받는 과정

#### UART_Periph.sv:79-165 (uart_rx)
```systemverilog
always_comb begin
    case (rx_state)
        IDLE: begin
            if (!rx) rx_next = START;  // ⑱ START 비트 감지 (0)
        end

        START: begin
            if (tick) begin
                if (tick_cnt_reg == 7) begin  // ⑲ 중간 지점 샘플링
                    rx_next = DATA;
                end
            end
        end

        DATA: begin
            if (tick) begin
                if (tick_cnt_reg == 15) begin
                    rx_out_next[data_cnt_reg] = rx;  // ⑳ 비트 저장
                    if (data_cnt_reg < 7)
                        data_cnt_next = data_cnt_reg + 1;
                    else
                        rx_next = STOP;
                end
            end
        end

        STOP: begin
            if (tick_cnt_reg == 15) begin
                rx_next = IDLE;
                // ㉑ rx_done 펄스 생성 (다음 클럭에)
            end
        end
    endcase
end
```

**rx_done 신호 생성** (uart_rx.sv:116-119):
```systemverilog
if (rx_next == IDLE && rx_state == STOP)
    rx_done_reg <= 1'b1;  // ㉒ 수신 완료!
else
    rx_done_reg <= 1'b0;
```

---

### 단계 8: Baud Tick Generator

#### UART_Periph.sv:530-564 (baud_tick_gen)
```systemverilog
parameter int BAUD_RATE = 9600;
localparam int BAUD_COUNT = 100_000_000 / (BAUD_RATE * 16);
// BAUD_COUNT = 651

always_comb begin
    if (count_reg == BAUD_COUNT - 1) begin
        tick_next = 1'b1;  // ㉓ 16x 오버샘플링 틱
        count_next = 0;
    end else begin
        tick_next = 1'b0;
        count_next = count_reg + 1;
    end
end
```

**타이밍**:
- 100MHz / (9600 * 16) = 651 클럭마다 tick
- 1 비트 = 16 tick = 651 * 16 = 10,416 클럭 = 104.16μs

---

### 단계 9: 전체 타이밍 다이어그램 (PC → FPGA 수신)

```
시간축:  0      104μs   208μs   312μs   ... 1040μs (10비트 완료)
         │      │       │       │           │
rx 핀:   1──┐   ┌───┬───┬───────...────┬───┐
            └───┘ 0 │ 0 │ 0     ...  1 │ 1 └─── (IDLE)
            START bit0 bit1    bit7  STOP

uart_rx:    IDLE→START→DATA(0)→DATA(1)→...→STOP→IDLE
                                                   ↓
                                              rx_done=1
                                                   ↓
RX FIFO:                                      wdata=0x48
                                              we=1
                                                   ↓
FIFO:                                         [0x48] 저장
                                              empty=0
                                                   ↓
C 코드:     while((USR & 0x01)==0) ← 루프 종료
                 ↓
            data = UART_RDR ─────────────────→ APB Read
                                                   ↓
APB Slave:                                    re_RX=1
                                                   ↓
FIFO:                                         rdata=0x48
                                              rptr++
                                                   ↓
C 코드:     return 0x48 ──────────────────────→ 수신 완료!
```

---

## 3. UART 송신 경로 (FPGA → PC)
### C 코드에서 'A' (0x41) 전송하는 전체 과정

---

### 단계 1: C 코드에서 UART 송신 시작

#### code2_reconstructed.c:123-131 (uart_send 함수)
```c
void uart_send(uint8_t data) {
    // ① TX FIFO에 공간이 있을 때까지 대기
    while ((UART_USR & UART_TX_READY) == 0);

    // ② TDR에 데이터 쓰기
    UART_TDR = data;  // 0x10004008 주소에 0x41 쓰기
}
```

**메모리 맵**:
```c
#define UART_TDR (*(volatile uint32_t*)(0x10004008))
```

**RISC-V 명령어**:
```assembly
SW   x10, 8(x11)    # x11 = 0x10004000 (UART 베이스)
                     # x10 = 0x41 ('A')
                     # 0x10004008에 쓰기
```

---

### 단계 2: CPU가 메모리 쓰기 명령 실행

#### DataPath.sv:200-230
```systemverilog
assign busAddr = aluResult;    // 0x10004008
assign busWe = memWrite;       // ③ 1 (쓰기)
assign busWData = rs2Data;     // ④ 0x41
assign transfer = memRead | memWrite;  // 1
```

---

### 단계 3: APB Master가 쓰기 트랜잭션 수행

#### APB_Master.sv:86-115
```systemverilog
case (state)
    IDLE: begin
        if (transfer) begin
            state_next = SETUP;
            temp_addr_next = addr;    // 0x10004008
            temp_wdata_next = wdata;  // ⑤ 0x41 저장
            temp_write_next = write;  // 1
        end
    end

    SETUP: begin
        PADDR = temp_addr_reg;   // 0x10004008
        PWRITE = temp_write_reg; // ⑥ 1 (쓰기)
        PWDATA = temp_wdata_reg; // ⑦ 0x41
        state_next = ACCESS;
    end

    ACCESS: begin
        PENABLE = 1'b1;
        // ⑧ UART Slave가 처리
    end
endcase
```

**APB 쓰기 타이밍**:
```
Clock:  __|‾‾|__|‾‾|__|‾‾|__
State:    IDLE|SETUP|ACCESS|
PSEL:     0   | 1   | 1   |
PENABLE:  0   | 0   | 1   |
PWRITE:   X   | 1   | 1   |
PADDR:    X   |0x10004008|
PWDATA:   X   | 0x41| 0x41|
PREADY:   X   | X   | 1   |
```

---

### 단계 4: APB_SlaveIntf_UART가 쓰기 처리

#### UART_Periph.sv:481-491 (쓰기 처리)
```systemverilog
if (PSEL && PENABLE) begin
    if (PWRITE) begin  // ⑨ 쓰기 사이클
        state_next = WRITE;
        unique case (PADDR[3:2])
            2'd2: slv_reg2_next = PWDATA;  // ⑩ TDR 쉐도우 저장
        endcase
        we_next = (PADDR[3:2] == 2'd2);  // ⑪ TX FIFO Write Enable
        PREADY_next = 1'b1;
    end
end
```

**주소 디코딩**:
- `PADDR = 0x10004008` → `PADDR[3:2] = 2'd2` → TDR

---

### 단계 5: TX 데이터 패스스루 메커니즘

#### UART_Periph.sv:433-437 (중요!)
```systemverilog
// ⑫ TDR 쓰기 싸이클일 때 PWDATA를 직접 FIFO로!
assign UWD = (PSEL && PENABLE && PWRITE && (PADDR[3:2] == 2))
           ? PWDATA[7:0]  // ⑬ 0x41을 바로 TX FIFO로
           : slv_reg2[7:0];  // 그 외에는 쉐도우 레지스터
```

**왜 이렇게 설계했나?**
- APB는 동기식이므로 쓰기 데이터를 바로 FIFO에 전달
- 1 클럭 지연 없이 즉시 전송 시작 가능

---

### 단계 6: TX FIFO에 데이터 저장

#### UART_Periph.sv:33-42 (TX FIFO)
```systemverilog
fifo U_FIFO_TX (
    .clk(PCLK),
    .reset(PRESET),
    .we(we_TX),         // ⑭ APB 쓰기 시 1
    .re(o_tx_done),     // ⑮ uart_tx 전송 완료 시 1
    .wdata(wdata_TX),   // ⑯ 0x41 (UWD)
    .rdata(rdata_TX),   // ⑰ uart_tx로 전달
    .empty(empty_TX),
    .full(full_TX)
);
```

**FIFO 쓰기 동작** (fifo_CU.sv:369-376):
```systemverilog
WRITE: begin
    if (!full_reg) begin
        wptr_next = wptr_reg + 1;  // ⑱ 쓰기 포인터 증가
        empty_next = 1'b0;         // ⑲ 비어있지 않음
        if (wptr_next == rptr_next)
            full_next = 1'b1;
    end
end
```

---

### 단계 7: uart_tx 모듈이 자동으로 전송 시작

#### UART_Periph.sv:62-68 (uart_tx 연결)
```systemverilog
uart_tx U_TX (
    .clk(PCLK),
    .rst(PRESET),
    .i_data(rdata_TX),      // ⑳ FIFO에서 읽은 데이터
    .tx_start(!empty_TX),   // ㉑ FIFO가 비어있지 않으면 시작!
    .tx(tx),
    .o_tx_done(o_tx_done)
);
```

**핵심**: `tx_start = !empty_TX`
- FIFO에 데이터가 들어오는 순간 자동으로 전송 시작
- CPU 개입 없이 하드웨어가 처리

---

### 단계 8: uart_tx 상태 머신

#### UART_Periph.sv:222-263 (uart_tx)
```systemverilog
always_comb begin
    case (state)
        IDLE: begin
            tx_next = 1'b1;  // IDLE 상태는 HIGH
            if (tx_start) begin  // ㉒ FIFO에 데이터 있음
                next = SEND;
                temp_data_next = i_data;  // ㉓ 0x41 저장
            end
        end

        SEND: if (tick) next = START;

        START: begin
            tx_next = 1'b0;  // ㉔ START 비트 (LOW)
            if (tick) begin
                if (tick_count_reg == 15) begin  // 16 tick = 1 bit
                    tick_count_next = 0;
                    next = DATA;
                end
            end
        end

        DATA: begin
            tx_next = temp_data_reg[bit_count_reg];  // ㉕ 비트 출력
            if (tick) begin
                if (tick_count_reg == 15) begin
                    if (bit_count_reg == 7)
                        next = STOP;  // ㉖ 8비트 전송 완료
                    else
                        bit_count_next = bit_count_reg + 1;
                end
            end
        end

        STOP: begin
            tx_next = 1'b1;  // ㉗ STOP 비트 (HIGH)
            if (tick && tick_count_reg == 15) begin
                next = IDLE;
                tx_done_next = 1'b1;  // ㉘ 전송 완료 펄스
            end
        end
    endcase
end
```

---

### 단계 9: tx_done 신호로 FIFO Pop

#### UART_Periph.sv:33-42 (다시)
```systemverilog
fifo U_FIFO_TX (
    .re(o_tx_done),  // ㉙ uart_tx가 전송 완료하면 FIFO에서 제거
    ...
);
```

**FIFO 읽기 동작**:
- `tx_done = 1` → FIFO `re = 1` → `rptr++`
- 다음 데이터가 있으면 자동으로 다시 전송 시작

---

### 단계 10: 전체 타이밍 다이어그램 (FPGA → PC 송신)

```
시간축:  0     1clk    2clk    100μs   200μs   ...   1040μs
         │     │       │       │       │             │
C코드:   uart_send(0x41) 호출
         │     │
APB:     IDLE→SETUP→ACCESS
               PADDR=0x10004008
               PWDATA=0x41
               PWRITE=1
         │           │
FIFO:              [0x41] 저장
                    empty=0
         │           │
uart_tx:          tx_start=1
                    IDLE→SEND→START→DATA...→STOP→IDLE
         │           │       │     │            │
tx 핀:   1───────────────┐   ┌─0─┬─1─...───┬───┐
                         └───┘START bit0     STOP└─1
         │                                         │
                                              tx_done=1
         │                                         │
FIFO:                                         rptr++
                                              [empty]
         │                                         │
PC:                                           'A' 수신!
```

---

## 4. APB 버스 트랜잭션 상세

### 4.1 APB 프로토콜 타이밍

#### 읽기 트랜잭션 (UART_USR 읽기)
```
Clock:    0   1   2   3   4
        ┌───┬───┬───┬───┬───┐
PCLK:   │   │   │   │   │   │
        └───┴───┴───┴───┴───┘

PSEL:   ────┐           ┌────
            └───────────┘

PENABLE:────────┐   ┌────────
                └───┘

PADDR:  XXXX│ 0x10004000  │XXX
            └─────────────┘

PWRITE: ────────────────────

PRDATA: XXXXXXXXXXXX│ 0x01 │
                    └──────┘

PREADY: ────────────┐   ┌────
                    └───┘

상태:     IDLE│SETUP│ACCESS│IDLE
              ↑     ↑
            디코더   데이터
            활성화   전송
```

#### 쓰기 트랜잭션 (UART_TDR 쓰기)
```
Clock:    0   1   2   3   4
        ┌───┬───┬───┬───┬───┐
PCLK:   │   │   │   │   │   │
        └───┴───┴───┴───┴───┘

PSEL:   ────┐           ┌────
            └───────────┘

PENABLE:────────┐   ┌────────
                └───┘

PADDR:  XXXX│ 0x10004008  │XXX
            └─────────────┘

PWRITE: ────┐           ┌────
            └───────────┘

PWDATA: XXXX│   0x41     │XXX
            └─────────────┘

PREADY: ────────────┐   ┌────
                    └───┘

상태:     IDLE│SETUP│ACCESS│IDLE
                    ↑
                  FIFO에
                  데이터 쓰기
```

---

### 4.2 APB Master 내부 동작

#### MCU.sv:73-93 (APB Master 연결)
```systemverilog
APB_Master U_APB_Master (
    .PCLK(clk),
    .PRESET(reset),
    // CPU 인터페이스
    .transfer(transfer),    // CPU가 버스 요청
    .ready(ready),          // 트랜잭션 완료
    .write(write),          // 읽기(0)/쓰기(1)
    .addr(addr),            // 주소
    .wdata(wdata),          // 쓰기 데이터
    .rdata(rdata),          // 읽기 데이터
    // APB 인터페이스
    .PADDR(PADDR),
    .PWRITE(PWRITE),
    .PENABLE(PENABLE),
    .PWDATA(PWDATA),
    // 각 Slave로 분배
    .PSEL_UART(PSEL_UART),
    .PRDATA_UART(PRDATA_UART),
    .PREADY_UART(PREADY_UART),
    ...
);
```

**신호 흐름**:
```
CPU → transfer=1 → APB Master
                     ↓
                  SETUP 상태
                     ↓
              decoder_en = 1
                     ↓
            주소 디코딩 (0x10004xxx)
                     ↓
              PSEL_UART = 1
                     ↓
                  ACCESS 상태
                     ↓
              PENABLE = 1
                     ↓
              Slave 처리 대기
                     ↓
              PREADY = 1
                     ↓
         ready = 1 → CPU로 응답
```

---

## 5. 실제 시나리오 완전 추적

### 시나리오: PC에서 'A' 전송 → FPGA에서 "OK[]" 응답

---

### 5.1 PC → FPGA: 'A' 수신

#### Step 1: PC에서 'A' (0x41) 전송
```
PC UART TX ─────→ FPGA RX 핀
  9600 baud       100MHz 샘플링
```

#### Step 2: baud_tick_gen이 16x 샘플링 틱 생성
```systemverilog
// 651 클럭마다 tick = 1
// 100MHz / 651 = 153.6kHz (9600 * 16)
```

#### Step 3: uart_rx가 비트 수신
```
시간:  0      104μs   208μs   312μs   ... 1040μs
rx:    1──┐   ┌───┬───┬───────────┬───┐
          └───┘ 0 │ 0 │ 0 ... 1   │ 1 └──
          START  b0  b1  b2... b7  STOP

uart_rx state:
IDLE → (rx=0 감지) → START
     → (7 tick 대기, 중간점 샘플) → DATA
     → (16 tick마다 비트 샘플, 8회) → STOP
     → (16 tick 대기) → IDLE
     → rx_done = 1 (1 클럭 펄스)
```

#### Step 4: RX FIFO에 저장
```systemverilog
// rx_done = 1일 때
fifo U_FIFO_RX (
    .we(rx_done),        // 1
    .wdata(wdata_RX),    // 0x41
    ...
);

// FIFO 내부
mem[wptr] <= 0x41;  // 메모리에 저장
wptr <= wptr + 1;   // 포인터 증가
empty <= 0;         // 플래그 업데이트
```

#### Step 5: C 코드 main loop에서 감지
```c
// main() 함수에서
uint32_t status = UART_USR;  // APB 읽기
                              // → PRDATA = {... , RX_READY=1}
status &= UART_RX_READY;

if (status != 0) {  // ← 조건 만족!
    received_data = uart_receive();  // 다음 단계로
}
```

#### Step 6: uart_receive() 실행
```c
uint8_t uart_receive(void) {
    // USR 폴링 (이미 데이터 있으므로 바로 통과)
    do {
        status = UART_USR;
    } while ((status & UART_RX_READY) == 0);

    // RDR 읽기 → APB Read 0x1000400C
    uint8_t data = (uint8_t)UART_RDR;
    return data;  // 0x41
}
```

**APB Read 상세**:
```
CPU: LW x10, 12(x11)  // 0x1000400C
      ↓
APB Master: IDLE → SETUP → ACCESS
  PADDR = 0x1000400C
  PWRITE = 0
  PENABLE = 1
      ↓
APB_SlaveIntf_UART:
  case(PADDR[3:2])
    2'd3:  // RDR
      PRDATA_next = {24'b0, URD};  // URD = FIFO rdata
      re_next = 1'b1;               // FIFO pop
      ↓
FIFO: rdata = mem[rptr] = 0x41
      rptr++
      if (wptr == rptr) empty = 1
      ↓
CPU: x10 = 0x41
      ↓
C: return 0x41
```

---

### 5.2 FPGA → PC: "OK[]" 응답

#### Step 7: process_command() 호출
```c
// main()에서
process_command(received_data);  // 0x41

// process_command 내부
if (cmd == 'A' || cmd == 0x41) {
    uart_send('O');   // 0x4F
    uart_send('K');   // 0x4B
    uart_send('[');   // 0x5B
    uart_send(']');   // 0x5D
    uart_send('\r');  // 0x0D
    uart_send('\n');  // 0x0A
}
```

#### Step 8: 첫 번째 uart_send('O') 실행
```c
void uart_send(uint8_t data) {  // data = 0x4F
    // TX FIFO 공간 확인
    while ((UART_USR & UART_TX_READY) == 0);

    // TDR 쓰기 → APB Write 0x10004008
    UART_TDR = data;
}
```

**APB Write 상세**:
```
CPU: SW x10, 8(x11)  // x10=0x4F, x11=0x10004000
      ↓
APB Master: IDLE → SETUP → ACCESS
  PADDR = 0x10004008
  PWRITE = 1
  PWDATA = 0x4F
  PENABLE = 1
      ↓
APB_SlaveIntf_UART:
  if (PWRITE && PADDR[3:2] == 2'd2)  // TDR
    we_TX = 1
    UWD = PWDATA[7:0] = 0x4F
      ↓
TX FIFO: mem[wptr] = 0x4F
         wptr++
         empty = 0
      ↓
uart_tx: tx_start = !empty = 1
         IDLE → SEND → START → DATA → STOP
      ↓
tx 핀: 1 → 0 (START) → 1,1,1,1,0,0,1,0 (0x4F) → 1 (STOP)
      ↓ (104μs * 10 = 1.04ms 후)
PC 수신: 'O'
```

#### Step 9: 나머지 문자들도 순차 전송
```
uart_send('K') → TX FIFO → uart_tx → PC 수신 'K'
uart_send('[') → TX FIFO → uart_tx → PC 수신 '['
uart_send(']') → TX FIFO → uart_tx → PC 수신 ']'
uart_send('\r') → ...
uart_send('\n') → ...
```

**FIFO 깊이 4의 의미**:
- 만약 CPU가 빠르게 4개 이상 쓰면 Full
- `while ((UART_USR & UART_TX_READY) == 0)` 에서 대기
- uart_tx가 하나 전송 완료 → FIFO pop → Full 해제
- CPU가 다음 데이터 쓰기

---

### 5.3 전체 시퀀스 다이어그램

```
시간축:  0ms      1ms      2ms      3ms      4ms      5ms      6ms
         │        │        │        │        │        │        │
PC TX:   'A'──────┘
         │ (1.04ms 전송)
         │        │
FPGA RX: │   uart_rx 수신
         │        │
         │   RX FIFO [0x41]
         │        │
C main:  │   USR 폴링 → RX_READY=1 감지
         │        │
         │   uart_receive() → 0x41
         │        │
         │   process_command(0x41)
         │        │
         │   uart_send('O')
         │        ↓
FPGA TX: │      TX FIFO [0x4F]
         │        │
         │      uart_tx 전송
         │        ↓ (1.04ms)
PC RX:   │        'O'──┘
         │             │
         │        uart_send('K')
         │             ↓
         │           TX FIFO [0x4B]
         │             ↓
         │           'K'──┘
         │                  │
         │             uart_send('[')
         │                  ↓
         │                '[' ──┘
         │                       │
         │                  uart_send(']')
         │                       ↓
         │                     ']'──┘
         │                            │
         │                       uart_send('\r')
         │                            ↓
         │                          '\r'──┘
         │                                 │
         │                            uart_send('\n')
         │                                 ↓
         │                               '\n'──┘
         │                                      │
PC 화면:  "OK[]\r\n" 출력 완료!
```

**총 소요 시간**: 약 6ms
- 'A' 수신: 1.04ms
- 처리: ~0.1ms (CPU 사이클)
- "OK[]" 전송: 4.16ms (4문자 * 1.04ms)
- "\r\n" 전송: 2.08ms

---

## 6. 핵심 설계 포인트 정리

### 6.1 메모리 맵 I/O의 장점
```c
#define UART_TDR (*(volatile uint32_t*)(0x10004008))

// 컴파일러가 자동 변환
UART_TDR = 'A';
   ↓
SW x10, 8(x11)  // RISC-V Store 명령
   ↓
APB Write 트랜잭션
   ↓
하드웨어 레지스터 업데이트
```

**장점**:
- 소프트웨어 관점: 일반 변수처럼 접근
- 하드웨어 관점: 표준 버스 프로토콜 사용
- 이식성: 주소만 바꾸면 다른 플랫폼 지원

---

### 6.2 FIFO의 역할

#### 문제 상황 (FIFO 없을 때):
```
CPU (100MHz) ─→ uart_tx (9600 baud)
빠름                      느림

CPU가 연속으로 데이터 쓰면?
→ uart_tx가 아직 전송 중
→ 데이터 손실!
```

#### 해결 (FIFO 있을 때):
```
CPU ─→ TX FIFO (4 byte) ─→ uart_tx
        버퍼링

CPU: 빠르게 4개 쓰기
FIFO: 저장
uart_tx: 천천히 하나씩 전송
```

**설계 결정**:
- 깊이 4 = 짧은 메시지 버퍼링
- "OK[]" = 4문자 → 딱 맞음!
- 더 긴 메시지는 폴링 필요

---

### 6.3 폴링 vs 인터럽트

#### 현재 (폴링 방식):
```c
while ((UART_USR & RX_READY) == 0);  // CPU 대기
```

**단점**:
- CPU가 다른 작업 못 함
- 전력 소모

**장점**:
- 구현 간단
- 검증 쉬움
- 타이밍 예측 가능

#### 개선안 (인터럽트 방식):
```c
void uart_rx_interrupt_handler(void) {
    // RX FIFO에 데이터 도착 시 자동 호출
    received_data = UART_RDR;
    process_command(received_data);
}

int main(void) {
    enable_interrupts();
    while(1) {
        // 다른 작업 가능
    }
}
```

---

### 6.4 APB vs AXI 선택 이유

#### APB 특징:
- **간단**: 2단계 프로토콜 (SETUP, ACCESS)
- **저속**: 주변장치용 (UART, GPIO, FND)
- **면적 작음**: 로직 최소화

#### AXI (사용 안 함):
- **복잡**: 5채널 (AR, R, AW, W, B)
- **고속**: 메모리, DMA용
- **오버킬**: UART에는 불필요

**결론**: APB가 UART에 최적

---

## 7. 발표 시 강조할 코드 연결점

### 7.1 소프트웨어 → 하드웨어 연결

```
C 코드                RISC-V 명령         APB 트랜잭션       하드웨어 동작
───────────────────────────────────────────────────────────────────────
UART_TDR = 'A'  →  SW x10, 8(x11)  →  PADDR=0x10004008  →  TX FIFO[0]='A'
                                       PWDATA=0x41            wptr++
                                       PWRITE=1               empty=0
                                       ↓                      ↓
                                       PREADY=1        →  uart_tx 시작
                                                          tx 핀 전송
```

### 7.2 하드웨어 → 소프트웨어 연결

```
하드웨어 동작          APB 트랜잭션       RISC-V 명령         C 코드
───────────────────────────────────────────────────────────────────────
PC → rx 핀        →  (uart_rx 수신)
   ↓                   rx_done=1
RX FIFO[0]='H'    →  empty=0
   ↓                   ↓
USR[0]=1          ←  PRDATA[0]=1    ←  LW x10, 0(x11)  ←  status=UART_USR
   ↓                   ↓                  x10=0x01           (0x01 반환)
FIFO rdata='H'    ←  PRDATA=0x48   ←  LW x10, 12(x11) ←  data=UART_RDR
rptr++                re=1               x10=0x48           return 0x48
```

---

## 8. 질문 대비 - 코드 레벨 답변

### Q: "C 코드에서 UART_TDR = 'A' 하면 어떻게 하드웨어가 동작하나요?"

**A (단계별 설명)**:

1. **컴파일**: GCC가 `SW x10, 8(x11)` 명령 생성
2. **CPU 실행**: DataPath.sv에서 ALU가 주소 계산
3. **버스 요청**: `transfer=1`, `busAddr=0x10004008` 출력
4. **APB 변환**: APB_Master.sv가 SETUP→ACCESS 전환
5. **주소 디코딩**: Decoder가 `PSEL_UART=1` 활성화
6. **Slave 처리**: APB_SlaveIntf_UART가 `PWDATA` 수신
7. **FIFO 쓰기**: `UWD=0x41`, `we_TX=1`로 TX FIFO 저장
8. **자동 전송**: `tx_start=!empty`로 uart_tx 시작
9. **물리 전송**: tx 핀으로 START-DATA-STOP 비트 출력

---

### Q: "FIFO 깊이가 4인데, 6문자 'OK[]\r\n'을 어떻게 보내나요?"

**A**:

```c
uart_send('O');  // FIFO [O]
uart_send('K');  // FIFO [O, K]
uart_send('[');  // FIFO [O, K, [], (전송 중)]
                 // uart_tx가 'O' 전송 완료 → FIFO [K, [], ()]
uart_send(']');  // FIFO [K, [], (), ]]
uart_send('\r'); // while 루프 대기 (FIFO Full)
                 // uart_tx가 'K' 전송 완료 → FIFO [[], (), ], (\r 추가 가능)]
uart_send('\n'); // 마찬가지로 대기 후 추가
```

**핵심**:
- `while ((UART_USR & TX_READY) == 0)` 폴링
- Full이면 대기, uart_tx가 전송 완료하면 재개

---

### Q: "APB 프로토콜에서 SETUP과 ACCESS 단계의 차이는?"

**A**:

**SETUP 단계** (APB_Master.sv:96-104):
```systemverilog
SETUP: begin
    PSEL = 1;      // Slave 선택
    PENABLE = 0;   // 아직 Enable 안 함
    PADDR = addr;  // 주소 출력
    PWDATA = data; // 데이터 출력 (쓰기일 때)
    // Slave는 아직 처리 안 함, 준비만
end
```

**ACCESS 단계** (APB_Master.sv:106-112):
```systemverilog
ACCESS: begin
    PSEL = 1;      // 유지
    PENABLE = 1;   // Enable!
    // Slave가 실제 처리
    wait(PREADY);  // 완료 대기
end
```

**이유**: Setup-Hold 타이밍 보장
- Setup: 신호 안정화 시간
- Access: 실제 데이터 전송

---

## 9. 코드 추적 예제 (발표 시연용)

### 예제 1: 'H' 송신 완전 추적

```python
# Python 시뮬레이션 스크립트
import serial
ser = serial.Serial('COM3', 9600)
ser.write(b'H')  # 0x48 전송
```

**FPGA 내부 추적**:

```
[0.000ms] PC UART TX → 'H' (0x48) 전송 시작
          rx 핀: 1 (IDLE)

[0.000ms] START 비트 감지
          rx 핀: 1 → 0
          uart_rx: IDLE → START

[0.052ms] 중간점 샘플 (7 tick)
          uart_rx: START → DATA
          data_cnt = 0

[0.104ms] bit 0 샘플 (rx=0)
          rx_out[0] = 0

[0.208ms] bit 1 샘플 (rx=0)
          rx_out[1] = 0

[0.312ms] bit 2 샘플 (rx=0)
          rx_out[2] = 0

[0.416ms] bit 3 샘플 (rx=1)
          rx_out[3] = 1

[0.520ms] bit 4 샘플 (rx=0)
          rx_out[4] = 0

[0.624ms] bit 5 샘플 (rx=0)
          rx_out[5] = 0

[0.728ms] bit 6 샘플 (rx=1)
          rx_out[6] = 1

[0.832ms] bit 7 샘플 (rx=0)
          rx_out[7] = 0
          uart_rx: DATA → STOP
          rx_out = 0b01001000 = 0x48

[0.936ms] STOP 비트 샘플
          uart_rx: STOP → IDLE
          rx_done = 1 (1 클럭 펄스)

[0.936ms] RX FIFO Write
          mem[0] = 0x48
          wptr = 0 → 1
          empty = 1 → 0

[0.937ms] C 코드 main() 루프
          status = UART_USR
          → APB Read 0x10004000
          → PRDATA = 0x00000001 (RX_READY=1)

[0.938ms] uart_receive() 호출
          data = UART_RDR
          → APB Read 0x1000400C
          → PRDATA = 0x00000048
          → FIFO re=1, rptr++

[0.939ms] return 0x48
          received_data = 0x48 ('H')
```

---

## 10. 결론 - 전체 시스템 통합

### 10.1 계층별 책임

| 계층 | 파일 | 주요 역할 |
|------|------|-----------|
| **응용** | code2_reconstructed.c | 비즈니스 로직, 명령어 처리 |
| **드라이버** | uart_send/receive 함수 | 레지스터 읽기/쓰기 |
| **버스** | APB_Master.sv | CPU-주변장치 통신 중재 |
| **주변장치** | UART_Periph.sv | 프로토콜 변환 (APB ↔ UART) |
| **물리** | uart_tx/rx | 비트 직렬화/역직렬화 |

### 10.2 데이터 경로 요약

**송신 경로**:
```
C 변수 → RISC-V 레지스터 → APB 버스 → UART 레지스터
→ TX FIFO → uart_tx → tx 핀 → PC
```

**수신 경로**:
```
PC → rx 핀 → uart_rx → RX FIFO → UART 레지스터
→ APB 버스 → RISC-V 레지스터 → C 변수
```

### 10.3 핵심 설계 철학

1. **계층 분리**: 각 계층이 독립적으로 동작
2. **표준 프로토콜**: APB, UART 표준 준수
3. **하드웨어 가속**: FIFO, 자동 전송으로 CPU 부담 감소
4. **확장성**: 새 주변장치 추가 용이

---

**END OF DOCUMENT**
